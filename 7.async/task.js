class AlarmClock {// Класс представляет будильник
    constructor() { //Конструктор
        this.alarmCollection = []; //свойства для хранения коллекции , присвоение в коллекцию пустого массива, тем самым 
    //это считается быстрой очисткой данной коллекции.
        this.intervalId = null;       //свойства для хранения id таймера  
    }
//добавляет новый звонок в коллекцию
    addClock(timeStart, callback) { 
        if (!timeStart || !callback) { //Если проверка истинна, тогда выбрасывается исключение с сообщением 
    //"Отсутствуют  обязательные аргументы"
            throw new Error("Отсутствуют обязательные аргументы");
        }

        // if (this.alarmCollection.some(alarm => alarm.time === timeStart)) {
        //     console.warn('Уже присутствует звонок на это же время');
        //     return;
    
        
        
        const newAlarm = { //Создание обьекта будильника
            time: timeStart,
            callback: callback,
            canCall: true
          };

        this.alarmCollection.push(newAlarm);// Добавляем newAlarm  в alarmCollection
        return console.log('Будильник установлен!'); // Возвращаем вывод в консоль
    }
//удаляет звонки по определённому времени
    removeClock(time) {              
        this.alarmCollection = this.alarmCollection.filter(alarm => alarm.time !== time);
    // получаем новый массив, отфильтровав элементы с помощью переданной колбэк-функции. Колбэк-функция будет вызвана для 
    //каждого элемента массива и по результату функции примет решение включать этот элемент в новый массив или нет.
    }
//возвр текущее время в стр.формате HH:MM 
    getCurrentFormattedTime() {            
        const now = new Date();//Создаем обьек new Date() со временем
        const hours = now.getHours().toString().padStart(2, '0'); // Получилил местное время
    // getHours метод возвращают компоненты относительно местного часового пояса.
    // toString метод преобразует в строку
    // padStart метод дополняет текущую строку другой строкой (при необходимости несколько раз), пока результирующая строка 
    //не достигнет заданной длины . Заполнение применяется с начала текущей строки.
        const minutes = now.getMinutes().toString().padStart(2, '0');
    // getMinutes() метод возвращает минуты для этой даты по местному времени
        return `${hours}:${minutes}`; // возвращем вывод в консоль hours: minutes 
    }
//запускает будильник
     start() { // Пишем функцию    
        //проверка наличия свойства для хранения таймера id (интервалов)                 
                if (this.intervalId !== null) { //Если свойства для хранения id таймера не равно null
                    return;   // прерываем выполнение метода start, раз сработало это услови
                }
        
                this.intervalId = setInterval(() => {// Присваиваем к свойству для хранения id таймера -установку интервала
                    const currentTime = this.getCurrentFormattedTime();// присваиваем свойству  currentTime -"Эта функция
    // используется для возврата текущего времени звукового файла в формате секунд, который воспроизводится в это время в Интернете
    // " свойство getCurrentFormattedTime() текущее время в стр.формате HH:MM
                
                    this.alarmCollection.forEach(alarm => {//С помощью метода массива forEach  перебираем  массив, 
    //выполняя предоставленную функцию один раз для каждого элемента массива в порядке возрастания индекса .
    // Эта функция называется функцией обратного вызова
                      if (alarm.time === currentTime && alarm.canCall) {// Если время звонока===текущему времени и свойство 
                        звонка
    // По условиям задачи, раз попали сюда, то должны поменять значение свойства на false и вызвать коллбэк ф-ию. 
    //Что и делают эти две строки кода - alarm.canCall = false; и alarm.callback().
                        alarm.canCall = false;//
                        alarm.callback();//
                      }
                    });
                  }, 1000);//с интервалом для вывода сообщения в 1 секунду
            }
//останавливает выполнение интервала будильника
    stop() {    // Пишем функцию для того, чтобы удалить интервал вывода сообщений
        clearInterval(this.intervalId);//Функция clearInterval() отменяет многократные повторения действий, 
    //установленные вызовом функции setInterval(). Примечание: значение идентификатора, возвращённого функцией setInterval() , 
    //используется в качестве параметра для clearInterval() 
        this.intervalId = null;//свойства для хранения id таймера  присваиваем null локально в этой функции
    }
    //сбрасывает возможность запуска всех звонков.
    resetAllCalls() {     //  Пишем функцию для сброса запусков всех звонков.
        this.alarmCollection.forEach(alarm => {//this.alarmCollection.forEach - перебираем коллекцию звонков. 
    //Каждый звонок (объект) передаём внутрь стрелочной ф-ии под именем alarm. У этого объекта есть свойство canCall
    // (значение запуска функции коллбека), в котором хранится булево значение - true/false. Следовательно на это место
    // подставится значение этого свойства и если оба результата true, то проверка сработает и попадём внутрь if. 
    //По условиям задачи, раз попали сюда, то должны поменять значение свойства на false и вызвать коллбэк ф-ию. 
    //Что и делают эти две строки кода - alarm.canCall = false; и alarm.callback().
    //С помощью метода массива forEach  перебираем  массив, выполняя предоставленную функцию один раз для каждого 
    //элемента массива в порядке возрастания индекса .
        alarm.canCall = true;// По условиям задачи resetAllCalls — сбрасывает возможность запуска всех звонков.
    // А данная возможность есть, если в свойстве canCall находится true. Вот и меняем любые значения на true. 
    //Значение запуска функции коллбека), в котором хранится булево значение - true/false
        });
    }
//удаляет все звонки
    clearAlarms() {    //     
        this.stop(); // Вызов метода остановки интервала
    //stop() останавливает дальнейшую загрузку ресурсов в текущем контексте просмотра, что эквивалентно кнопке остановки в 
    //браузере . Из-за того, как выполняются сценарии, этот метод не может прервать загрузку своего родительского документа, 
    //но он остановит его изображения, новые окна и другие загружаемые объекты
        this.alarmCollection = [];// присвоение в коллекцию пустого массива, тем самым это считается быстрой очисткой 
    //данной коллекции.
    }
}

const alarm = new AlarmClock();// создаём экземпляр класса

// console.log(alarm);
console.log(alarm.addClock('16:45', () => console.log('Будильник установлен!')));//
console.log(alarm.alarmCollection.length);//выводим в консоль длину коллекции, т.е. сколько есть/установлено будильников
// console.log(alarm);
// console.log(alarm.removeClock('16:45'));
// console.log(alarm);
alarm.clearAlarms();// вызываем метод очистки коллекции звонков. Следующей строкой 
console.log(alarm);//убеждаемся, что коллекция очищена.
console.log(alarm.alarmCollection.length);//
   

















